### 对象(objects), 值(values)和类型(types)

*对象(objects)*是关于数据(data)的抽象, 在python中, 所有的数据都以对象或者对象间的关系来表示.(代码(code)我们也用对象来表示, 在某种意义上, 这正符合了冯.诺依曼的程序存储模型).

每个对象都有id, 类型和值三个属性. 对象的id从创建之后就不再改变, 比如, 你可以用内存地址来表示对象的id. `is`操作符用来检查两个对象的id是否相同, `id()`函数返回一个整数来表示对象的id.

> **CPython的实现细节**: `id(x)`返回x的内存地址.

对象的类型决定了该对象支持的操作集(operations)(例: 该对象是否有长度)和该对象可能的值(values). `type()`函数返回对象的类型(该类型本身也是一个对象), 和id一样, 对象的类型也是不可改变的.

有些对象的值是可变的, 我们称其为*mutable*, 对于不可变的对象则称之为*immutable*. 当一个immutable的容器(container)中包含的引用是指向mutable的对象时, 那么我们说该容器的值也是可变的, 但该容器对象仍然被认作是不可变的, 所以对象的不可变并不完全等同于该对象值的不可变. 对象的可变性取决于对象的类型, 例如: 数字(numbers), 字符串(strings)和元组(tuples)是不可变的, 列表(lists)和字典(dictionaries)是可变的.

对象从来不会被显示地清除, 但是, 当该对象不再被其他对象使用时, 它可能会被当做垃圾回收.

> **CPython的实现细节**: 回收策略目前使用的是引用计数和延迟循环引用检测(可选), 这种策略能够尽可能快地回收那些不可用的对象, 但是不保证能够立马回收那些具有循环引用的对象. 用户可以查看`gc`模块来获取关于如何控制循环引用下垃圾回收的信息. 其他的实现方式可能不同, CPython也可能改变其实现, 因此, 不要依赖于对象不可用时的终止化(finalization)过程(所以你总是应该显式地关闭文件).

注意, 当你使用一些跟踪(tracing)或调试(debugging)工具时, 可能会导致一些正常情况下被回收的对象仍然存活(alive), 另外当你使用`try...except`时也会有一些对象不被立马回收.

有一些对象会包含对外部资源(如文件和窗口)的引用, 因此我们期望当该对象被回收后, 它所指向的那些资源也能够被释放(freed), 但是由于回收过程不保证能立马执行, 所以那些对象通常都需要提供显式的方式来释放那些资源, 比如常见的`close()`方法.我们建议在程序中始终显式地执行那些方法. `with`和`try...finally`为你执行那些方法提供了便利.

有一些对象包含有对其他对象的引用, 我们称之为容器(container). 元组, 列表, 字典都是容器. 容器包含的引用是该容器值的一部分, 大部分情况下, 当我们说容器的值时, 我们说的不是容器包含的那些引用, 而是容器本身. 但是当我们说容器的可变性时, 我们说的是容器包含的对象的可变性, 所以一个不可变的容器(比如元组)包含可变对象的引用时, 该容器的值则随着所包含对象的变化而变化.

类型几乎影响了对象的方方面面, 甚至包括对象的id: 对于不可变的类型, 那些计算出新值的操作可能返回一个指向已存对象的引用, 而这在可变对象的情况下是不允许的. 比如, 在执行`a = 1; b = 1`后, a和b可能指向相同的对象, 但是执行`c = []; d = []`后, c和d一定会指向不同的对象.(注意如果`c = d = []`则是将相同的对象赋给c和d).

### 标准类型结构(The standard type hierarchy)

下面是一些内建于python中的类型. 扩展模块(extension modules)可以定义额外的类型, 未来的版本也可能添加新的类型(例如实数, 高效存储整数数组等), 尽管这些类型经常会通过标准库的形式来提供.

下面有些类型的描述中会包含关于特殊属性(special attributes)的段落, 这些属性通常用来访问实现中的相关细节, 并不适合于通常情况下的使用.(那些属性的定义可能会在将来进行调整).

**`None`**: 此类型只包含一个值且只有一个对象代表此值, 该对象可以通过`None`名称来访问. 在很多情况下, 我们会用该对象来表示某个值的缺失(absence), 比如我们当一个函数不返回任何值时, 我们用`None`来代替. 它的真值测试(truth value)为`False`.

**`NotImplemented`**: 此类型只包含一个值且只有一个对象代表此值, 该对象可以通过`NotImplemented`名称来访问. 数值方法(numeric methods)以及富比较(rich comparison methods)方法在未实现时应该返回此值(取决于具体的方法, 解释器会接着尝试该方法的镜像操作(reflected operation)或其他后备操作). 它的真值测试为`True`.[注: 镜像操作举例, `==`的镜像操作为`!=`]

**`Ellipsis`**: 此类型只包含一个值且只有一个对象代表该值, 该对象可以通过`...`字面量或者`Ellipsis`名称来访问. 它的真值测试为`True`.

**`numbers.Number`**: 数值类型的对象通常由字面量创建或由相关算术操作函数返回. 数值类型是不可变的, 一旦被创建, 他们的值就不能被改变. python中的数值和数学中的数值有着很强的相关性, 除了多了些关于计算机方面的限制.

Python将数值区分为三种子类型: 整数(integers), 浮点数(floating point numbers)和复数(complex numbers).

*   **`numbers.Integral`**: 表示了数学中的整数(正整数与负整数), 具体又分为两类.
    *    Integers(`int`): 这个表示了所有的整数, 范围取决于可用的(虚拟)内存. 位移(shift)和掩码(mask)操作都基于整数的二进制表示, 负整数会以补码的形式表示, 同时左边补上符号位.
    *    Booleans(`bool`): 表示了真值测试中的两个值`True`和`False`, 分别用对象`True`和`False`表示. Boolean是integer的子类, 大部分情况下, 它的两个值在整数中的行为分别等同于`1`和`0`, 除了在转换成字符串时, 他们会分别转成`"True"`和`"False"`.

*   **`numbers.Real(float)`**: 表示了机器层面的双精度浮点数. 关于浮点数的范围以及如何处理溢出都依赖于底层系统的架构. Python不支持单精度浮点数, 因为使用单精度浮点数在处理器以及内存方面的节省(savings)通常都不及使用objects带来的开销, 所以我们没有必要使用两种精度的浮点数来使语言变得更复杂.

*   **`numbers.Complex(complex)`**: 表示了一对(pair)机器层面的双精度浮点数. 因此约束与限制都可以参考上面的浮点数. 复数`z`的实部和虚部可以通过它的两个只读属性(`z.real`和`z.imag`)来获得.

**`Sequences`**: 表示有穷(finite)有序(ordered)通过非负整数来索引的序列. `len()`函数返回序列中元素的个数. 索引值从0开始, 因此当序列中元素个数为`n`时, 索引(index)的最大值为`n-1`, `a[i]`表示第i个元素.

序列支持切片(slicing)操作, `a[i:j]`选择了序列a中索引k大于等于i小于j(i <= k < j)的所有元素. 切片操作作为表达式时, 它表示的是一个新的同类型的序列(也就是说返回的序列的索引重新调整为从0开始).

有些序列还支持扩展的切片操作(extended slicing), 它允许提供第三个参数指定步长(step). `a[i:j:k]`选择了所有索引x的值, 且x满足`x = i + n * k`和`i <= x < j`.

序列根据它的可变性分为两种:

*    **不可变序列**: 不可变序列对象一旦创建就不可再改变.(它包含的其他对象可能是可变的, 因而它们的值也是可以变化的, 然而由不可变的引用直接指向的对象是不能改变的). 以下类型是不可变序列:

    *   **`Strings`**: string是unicode码的序列. 它的每个unicode码值处在`U+0000-U+10FFFF`范围中. Python没有`char`这种类型, 取而代之的是一个长度为1的string. `ord()`函数将一个unicode码的string形式转成一个`0 - 10FFFF`范围内的整数, `chr()`函数则将一个处在`0 - 10FFFF`范围内的整数转成对应的长度为1的string. `str.encode()`方法可以将string以特定编码转成bytes对象. `bytes.decode()`方法则相反, 它将bytes对象转成特定编码的string.

    *   **`Tuples`**: tuple中的项可以是任意的Python对象. 含两项及两项以上的tuple由逗号分隔的表达式组成. 只含有一项的tuple需要在该表达式后附加一个逗号(因为括号必须用来将表达式分组(grouping), 同时单个表达式本身也无法组成tuple). 空的元tuple由一对空括号表示.

    *   **`Bytes`**: bytes是不可变的数组, 它的每一项都是由8个bit组成的byte(用整数来表示就处在`0-256`之间). bytes字面量(`b'abc'`)和`bytes()`函数可以用来创建bytes对象. 同样, bytes对象可以通过`decode()`方法可以转成字符串.

*   **可变序列**: 可变序列在创建之后仍然可以改变. 下标(subscription)和切片标记(slicing)都可以用来作为赋值的对象和`del`语句的参数. 目前有两种内建可变的序列类型(扩展模块`array`和`collections`提供了一些其他的可变序列类型):

    *   **`Lists`**: list中的每一项可以是任意的Python对象. 它由用逗号分隔的表达式加上方括号组成. (针对长度为0或1的list, 我们并没有特殊的标记).

    *   **`Byte Arrays`**: bytearray对象是一个可变的数组. 该对象由`bytearray()`构造方法创建. 它和bytes对象的区别只在于它是不可变的(因而也是无法进行hash的), 其他的接口及功能都是一样的.

**`Set`**: 集合类型表示无序(unordered)有穷(finite)唯一(unique)不可变(immutable)的对象集. 因此, 集合中的对象无法用数值下标(subscription)进行索引. 但是, 它可以被遍历(iterated over), `len()`函数返回集合中的元素数量. 集合类型的常见使用场景: 快速成员检查(membership testing), 序列去重(remove duplicates)和一些常见的数学计算(交集, 并集, 差集, 对称差集等).

集合中的元素, 和字典中的键值一样, 需要是不可变类型. 注意数值类型遵循数值上的比较规则: 如果两个数值比较起来是相等的(如`1`和`1.0`), 那么只有其中一个能出现在集合中.

目前有两种内建的集合类型:

*   **`Sets`**: 表示可变的集合, 通过内建构造函数`set()`创建. 创建之后可以通过若干方法来改变它(如`add()`方法).

*   **`Frozen sets`**: 表示不可变的集合, 通过内建构造函数`frozenset()`创建. 因为frozenset是不可变的, 也是可hash的, 因此它本身也可以作为集合中的元素或作为字典的键值.

**`Mappings`**: 表示有穷(finite)的通过任意集合索引的对象集. `a[k]`表示从映射`a`中取出由`k`索引的对象值, 它可以作为赋值的对象也可以作为`del`语句的参数. `len()`函数返回映射中的所有元素个数.

目前只有一种内建的映射类型:

*   **`Dictionaries`**: 表示有穷(finite)的通过几乎任意对象索引的对象集. 不能用来作为索引的类型包括列表, 字典以及其他任何通过值比较而不是通过对象id来比较的可变类型, 之所以有这个限制是因为字典的实现要求索引的hash值是一个固定的常数. 数值类型作为索引遵循数值比较的规则: 如果两个数值比较起来相等的话, 那么不管用哪个做索引, 访问的值都是一样的. 字典类型是可变的, 它可以通过`{...}`标记来创建. 扩展模块`dbm.ndbm`, `dbm.gnu`和`collections`中提供了其他的映射类型.

**`Callable types`**: 有两种类型可以执行函数操作.

*   **`User-defined functions`**: 用户自定义的函数通过函数定义来创建, 调用该函数时需要提供和形参数量相同的参数列表. 它拥有以下特殊属性:

| 属性               | 含义                                                              |       |
|-------------------|------------------------------------------------------------------|-------|
| `__doc__`         | 函数的文档字符串, 如果没有, 则为`None`, 不会被子类继承                    | 可写   |
| `__name__`        | 函数的名字                                                         | 可写   |
| `__qualname__`    | 函数的全限定名称, Python3.3中新加的                                   | 可写   |
| `__module__`      | 函数所定义在的模块, 如果没有, 则为`None`                                | 可写   |
| `__defaults__`    | 函数中所有拥有默认值的参数值组成的元组, 如果没有, 则为`None`                | 可写   |
| `__code__`        | 编译后函数体的代码对象                                                | 可写   |
| `__globals__`     | 指向全局变量字典的引用, 即所定义在的模块的全局命名空间                      | 只读   |
| `__dict__`        | 一个字典引用, 用来存储在函数上添加的任意属性                              | 可写   |
| `__closure__`     | 函数中对自由变量绑定的元组                                             | 只读   |
| `__annotations__` | 存储参数注解的字典, 字典的键值为参数名, 如果带有return注解, 则键值为`return`  | 可写  |
| `__kwdefaults__`  | 仅存储关键字参数(keyword-only)的默认值字典                              | 可写  |

基本上所有标为可写的属性在进行赋值时都会做类型检查.

函数对象也支持用点标记(dot-notation)获取和设置任意属性, 比如给函数添加元数据信息(metadata). *注意在目前的实现中, 只有用户定义的函数支持设置其他属性, 内建函数不支持(未来的版本可能会支持)这一操作*.

关于函数定义的其他信息可以通过代码对象来获得.

*   **`Instance methods`**: 实例方法涉及到类, 类实例和其他可调用对象(通常是用户定义的函数).

在实例方法仅可读的特殊属性中, `__self__`是类实例, `__func__`是函数对象, `__doc__`是方法的文档字符串(与`__func__.__doc__`相同). `__name__`是方法的名称(与`__func__.__name__`相同), `__module__`是包含该方法定义的模块, 如果没有, 则为`None`.

实例方法也支持访问`__func__`的任意属性.

当我们获取一个类或类实例的属性, 并且该属性恰好是一个用户定义的函数或类方法时, 方法对象就被创建了.

当我们从类实例访问实例方法(instace method)时, 该方法的`__self__`就是该类实例. 并且我们称原函数被绑定了. 实例方法的`__func__`属性为原用户定义的函数对象.

当我们从类或类实例的其他实例方法获取一个实例方法时, 这个方法和普通函数对象的行为是一样的, 除了该方法的`__func__`属性不是原来的方法对象, 而是该方法对象的`__func__`属性.

当我们从类或类实例访问类方法(class method)时, 该方法的`__self__`为类本身. 类方法的`__func__`属性为原函数对象.

```python
# 上面这几句话需要解释一下(非原文, 译者加上的):
class A:
    def f(self):
        pass
    @classmethod
    def cf(cls):
        pass

# 从类实例访问实例方法
a = A()
a.f()
# 从类实例的其他实例方法创建实例方法
b = A()
b.g = b.f # b.g为新创建的实例方法
b.g.__func__ == b.f.__func__ # True
A.h = A.f # A.g为新创建的实例方法
c = A()
c.h.__func__ = c.f.__func__ # True
# 从类或类实例访问类方法
A.cf == a.cf
A.cf.__self__ == A # True
```

当一个实例方法被调用时, 该实例方法的`__func__`指向的函数对象被执行, 同时将类实例本身(`__self__`)插入到参数列表中第一位. 比如说类`C`定义了一个函数`f`, `x`是类`C`的一个实例, 那么`x.f(1)`等价于`C.f(x, 1)`.

当一个实例方法刚好来自于类方法时, 那么该实例方法的`__self__`则是类本身, 所以`x.f(1)`和`C.f(1)`等价于`f(C, 1)`.

注意当我们每次从实例访问函数对象时, 该函数对象会自动转换成实例方法对象. 在某些情况下, 我们可以通过优化来避免这里的多次转换开销, 比如我们将该实例属性保存成一个局部变量. 同时你也要注意这个转换过程只针对用户定义的方法对象, 其他的可调用以及不可调用对象都不会有这个过程. 还需要注意类实例的函数属性不会转成绑定方法, 只有当该函数对象是类的属性时才会发生转换.

*   **`Generator functions`**: 使用了`yield`语句的函数或者方法被称作生成函数(*generator function*), 这样的函数在被调用时, 总是会返回一个迭代器(iterator)对象. 调用该迭代器的`iterator.__next__()`方法时会执行该函数直到`yield`提供了一个值. 当该函数有`return`语句或已经执行到最后, 此时会产生一个`StopIteration`异常用来表示该迭代器已经没有更多值了.

*   **`Built-in functions`**: 内建函数是对底层C函数的包装, 比如`len()`和`math.sin()`(`math`是内建模块), 参数的数量和类型取决于被包装的C函数, 一些特殊的只读属性包括: `__doc__`是函数的文档字符串, 如果没有, 为`None`, `__name__`是函数的名称, `__self__`为`None`, `__module__`是该函数定义处在的模块, 如果没有, 则为`None`.

*   **`Built-in methods`**: 它也是对底层C函数的包装, 只是该C函数在调用时会隐式地传一个对象参数. 比如`alist.append()`是一个内建方法(假定`alist`是一个list对象). 它的`__self__`属性为该对象参数.

*   **`Classes`**: 类也是可调用的, 它通常用来作为创建类实例的工厂, 当然如果你重载`__new__`方法的话, 你也可以创建其他类的实例. 调用类时的参数会传给`__init__`方法, 在大部分情况下, 我们通过`__init__`方法来初始化该实例.

*   **`Class Instances`**: 如果该类实例有`__call__`方法的话, 那么该类实例也是可以调用的.
